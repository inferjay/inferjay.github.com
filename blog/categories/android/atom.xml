<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Inferjay的技术博客]]></title>
  <link href="http://inferjay.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://inferjay.github.io/"/>
  <updated>2013-09-26T13:49:54+08:00</updated>
  <id>http://inferjay.github.io/</id>
  <author>
    <name><![CDATA[inferjay]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Update Android Studio Fail]]></title>
    <link href="http://inferjay.github.io/blog/2013/09/26/update-android-studio-fail/"/>
    <updated>2013-09-26T12:53:00+08:00</updated>
    <id>http://inferjay.github.io/blog/2013/09/26/update-android-studio-fail</id>
    <content type="html"><![CDATA[<h2 id="macandroid-studio">Mac下解决无法更新Android Studio的问题</h2>

<p>昨天在G+中看到Android Studio又有更新了就心血来潮想去更新体验一下，可是无论我怎么点Check Update却一直提示<code>Connection failed. Please check your network connection and try again</code>，开始以为是由于G*W在捣乱，但是设置了Proxy后还是无法更新，然后开始问谷哥找到了解决办法。</p>

<p>首先打开<code>Finder</code>在左边选择<code>Application</code>目录，在右边找到<code>Android Studio.app</code>,然后右击选择“显示包内容”如下图：</p>

<p><img src="/images/notes_images/android_studio_in_finder.png" alt="alt text" title="android_studio_in_finder" /></p>

<p>接着用自己趁手的编辑器打开bin目录下的idea.vmoptions文件添加如下内容：</p>

<p><code>
-Djava.net.preferIPv4Stack=true  
-Didea.updates.url=http://dl.google.com/android/studio/patches/updates.xml  
-Didea.patches.url=http://dl.google.com/android/studio/patches/  
</code>
保存后，重新打开<code>Android Studio</code>点击Check Update就会弹出更新信息提示了</p>

<p><img src="/images/notes_images/check_update_info.png" alt="alt text" title="check_update_info" /></p>

<p>如果仍然无效，将url里的修改<code>http</code>为<code>https</code>，然后重启点击Check Update试试~~~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译]Google　I/O 2013:Volley 图片缓存教程]]></title>
    <link href="http://inferjay.github.io/blog/2013/08/03/google-i-o-2013-volley-image-cache-tutorial/"/>
    <updated>2013-08-03T11:28:00+08:00</updated>
    <id>http://inferjay.github.io/blog/2013/08/03/google-i-o-2013-volley-image-cache-tutorial</id>
    <content type="html"><![CDATA[<p>Gooogle I/O 2013已经结束了，并且对于Android开发的未来它给我们留下了更大的期望。令人非常兴奋的是在今年的I/O大会上展示了一个叫<a href="https://android.googlesource.com/platform/frameworks/volley/"><code>Volley</code></a>的库。<code>Volley</code>是一个处理和缓存网络请求的库，减少开发人员在实际的每一个应用中写同样的样板代码。写样板代码是很无聊的并且也增加了开发人员出错的几率。Google是出于这些考虑创建了<code>Volley</code>。</p>

<p>如果你还没有看过<a href="https://developers.google.com/events/io/sessions/325304728">Gooogle　I/O中关于Volley的介绍</a>，在继续这篇文章之前我建议你先去看看关于<code>Volley</code>的介绍，对它有一些基本的理解。</p>

<p>在Google I/O介绍的时候，Ficus Kirpatrick讲了很多关于Volley如何的有助于图片加载。你会发现在Volley作为你的图片加载解决方案的时候，虽然Volley自己处理了L2的缓存，它需要但是没有包含L1的缓存。许多人会使用像<a href="https://github.com/nostra13/Android-Universal-Image-Loader">Universal Image Loader</a>或者<a href="https://github.com/square/picasso">Square`s newer Picasso</a>这些第三方的库去处理图片的加载；然而这些库通常已经同时处理了图片的加载和缓存。所以，我们如何使用Volley来替换图片的加载和缓存呢？首先，让我们看看Volley提供的便利的加载方法，我们稍后再看他们的不同之处。</p>

<!--More-->

<h4 id="imageloader">ImageLoader</h4>

<p><code>ImageLoader</code>这个类需要一个<code>Request</code>的实例以及一个<code>ImageCache</code>的实例。图片通过一个<code>URL</code>和一个<code>ImageListener</code>实例的<code>get()</code>方法就可以被加载。从哪里，<code>ImageLoader</code>会检查<code>ImageCache</code>,而且如果缓存里没有图片就会从网络上获取。</p>

<h4 id="networkimageview">NetworkImageView</h4>

<p>这个类在布局文件中替换<code>ImageViews</code>，并且将使用<code>ImageLoader</code>。<code>NetworkImageView</code>的<code>setUrl()</code>这个方法需要一个字符串的URL路径以及一个<code>ImageLoader</code>的实例。然后它使用<code>ImageLoader</code>的<code>get()</code>方法获取图片数据。</p>

<p>```
<com.android.volley.toolbox.networkimageview android:id="@+id/twitterUserImage" android:layout_alignparentleft="true" android:layout_alignparenttop="true" android:layout_width="40dp" android:layout_height="40dp" android:padding="5dp" /></p>

<p>```</p>

<h4 id="imagecache">ImageCache</h4>

<p><code>Volley</code>的<code>ImageCache</code>接口允许你使用你喜欢的L1缓存实现。不幸的是<code>Volley</code>没有提供默认的实现。在I/O的介绍中展示了<code>BitmapLruCache</code>的一点代码片段，但是<code>Volley</code>这个库本身并不包含任何相关的实现。</p>

<p><code>ImageCache</code>接口有两个方法，<code>getBitmap(String url)</code>和<code>putBitmap(String url, Bitmap bitmap)</code>.这两个方法足够简单直白，他们可以添加任何的缓存实现。</p>

<h4 id="volley">在Volley中添加图片缓存</h4>

<p>对于这个例子，我创建了<a href="https://github.com/rdrobinson3/VolleyImageCacheExample">一个简单的应用</a>，它从Twitter上搜索提取“CapTech”这个词的推文，并且把包含这个词的推文的用户名和照片显示在一个ListView中，在你滑动这个列表的时候将自动加载以前的记录，并根据需要从缓存中拉取图片。</p>

<p><img src="/images/notes_images/volley-example.png" alt="alt text" title="volley-example" /></p>

<p>例子里有２个可用的缓存实现。一个基于内存的LRU缓存。对于磁盘缓存实现我选择使用由Jake Wharton写的<a href="https://github.com/JakeWharton/DiskLruCache">DiskLruCache</a>。我只所以选择这个实现是因为他在Android社区中被经常使用和推荐的并且有一些人试图去改进它。使用一个基于磁盘的L1缓存有可能导致i/o阻塞的问题。<code>Volley</code>已经内置了一个磁盘L2缓存。磁盘L1缓存包括在内了，由于我原来不知道<code>Volley</code>是如何处理图片请求缓存的。</p>

<h3 id="section">在这个例子中主要的组件实现如下:</h3>

<h4 id="requestmanager">RequestManager</h4>

<p><code>RequestManager</code>维护了我们的一个<code>RequestQueue</code>的引用。<code>Volley</code>使用RequestQueue不仅处理了我们给Twitter的数据请求，而且也处理了我的的图片加载。</p>

<h4 id="requestqueue">RequestQueue</h4>

<p>这个类虽然跟图片加载没有直接的关系，但是它是具有代表性，它是如何继承<code>Volley</code>的<code>Request</code>类去处理你的JSON解析。它使用GET请求到Twtter并获取<code>TwitterData</code>对象。</p>

<h4 id="bitmaplruimagecache">BitmapLruImageCache</h4>

<p>这是一个基于<code>“least recently used(最近最少使用算法,简称LRU)”</code>内存缓存实现。它是快速的并且不会引起I/O阻塞的。推荐这种方法。</p>

<h4 id="disklruimagecache">DiskLruImageCache</h4>

<p><code>DiskLruImageCache</code>是一个<code>DiskLruCache</code>和<code>bitmap-centered</code>的包装实现。它从<code>DiskLruCache</code>中获取和添加<code>bitmaps</code>，并且处理缓存的实例。一个磁盘缓存或许会引起I/O的阻塞。</p>

<h4 id="imagecachemanager">ImageCacheManager</h4>

<p><code>ImageCacheManager</code>持有一个我们的<code>ImageCache</code>和<code>Volley ImageLoader</code>的引用。</p>

<p>有一件事情你要注意，在ImageCacheManager中我们使用了字符串URL的hashCode()值作为缓存的Key。这么做是因为在URL中的某些字符不能作为缓存的Key。</p>

<h4 id="buzzarrayadapter">BuzzArrayAdapter</h4>

<p>这是一个简单的Adapter。这里唯一要注意的是我们实现了Volley的Listener和ErrListener接口并且将这个Adapter作为
NetworkImageView’s的setUrl(String string , Listener listener, ErrorListener errorListener) 方法的Listener。这个Adapter还有一点额外的代码，用来在滚动的时候加载老的推文。</p>

<p><code>
Tweet tweet = mData.get(position);
if(tweet != null){
viewHolder.twitterUserImage.setImageUrl(tweet.getUserImageUrl(),ImageCacheManager.getInstance().getImageLoader());
	viewHolder.userNameTextView.setText("@" + tweet.getUsername());
	viewHolder.messageTextView.setText(tweet.getMessage());
	viewHolder.tweetTimeTextView.setText(formatDisplayDate(tweet.getCreatedDate()));
	viewHolder.destinationUrl = tweet.getDestinationUrl();
}
</code></p>

<h4 id="putting-it-all-together">Putting it all together</h4>

<p>把这些组件组合在一起，图片加载和缓存是如此的简单。在启动时，在<code>MainApplication</code>这个类中初始化<code>RequestManager</code>和<code>ImageCacheManager</code>。在那里你可以定义你想要的L1缓存类型。内存缓存是默认的。</p>

<p>在<code>MainActivity</code>中我们调用<code>TwitterManager</code>并且加载我们的的初始数据集。一旦我们接收到响应我们就把这个响应传递给一个<code>BuzzArrayAdapter</code>并把这个<code>Adapter</code>设置到我们的<code>ListView</code>上。</p>

<p>正如我们已经在上面看到了<code>BuzzArrayAdapter</code>的代码,对于<code>NetworkImageView</code>所有繁重的图片加载操作我们仅仅需要从我们的<code>ImageCacheManager</code>中获取一个ImageLoader的实例传递给它就可以了。</p>

<p><code>ImageCacheManager</code>会检查我的LRU缓存实现并且如果这个图片是可用的就会返回它。如果这个图片不在在缓存中那么就从网络获取它。</p>

<p>当你滚动<code>ListView</code>的时候<code>BuzzArrayAdapter</code>将一起加载额外的推文和图片，并且重用在缓存中已经存在的图片。</p>

<h4 id="closing-thoughts-on-volley">Closing Thoughts on Volley</h4>
<p>虽然<code>Volley</code>是好用的，快速的，很容易实现的；但他也有一些不足的地方:</p>

<ul>
  <li>这个库没有任何的文档和例子。</li>
  <li>比如缓存配置组件，他们为什么不做成可配置的。</li>
  <li>从以上可以看出，除了一个比较奇怪的基本图片缓存实现以外,它甚至可能有使用NoImageCache的实现,或者在缓存完全可选的时候，你只是想从网络上获取任何东西。</li>
</ul>

<p>关于Volley在开发者社区中有很多令人激动的事情，并且有很的好的理由。感觉它就像一个库，它包含了一部分旧的Android API.像在I/O上公布的新的定位API,它是非常纯净的~~~~</p>

<h4 id="github">Github上的例子源码</h4>

<p><a href="https://github.com/rdrobinson3/VolleyImageCacheExample">VolleyImageCacheExample</a></p>

<h4 id="section-1">附件:</h4>

<p><a href="http://blogs.captechconsulting.com/sites/default/files/VolleyImageCacheExample-master.zip">VolleyImageCacheExample-master.zip</a></p>

<h4 id="section-2">原文作者:</h4>

<p>Trey Robinson</p>

<h4 id="section-3">原文地址:</h4>

<p><a href="http://blogs.captechconsulting.com/blog/raymond-robinson/google-io-2013-volley-image-cache-tutorial">http://blogs.captechconsulting.com/blog/raymond-robinson/google-io-2013-volley-image-cache-tutorial</a></p>

<h4 id="section-4">关于本文</h4>

<p>前端时间偶然间看到了<code>Volley</code>，最近开始做一个新项目又重新去看了看I/O中关于<code>Volley</code>的介绍,感觉<code>Volley</code>很牛逼，于是就想在新项目中试试<code>Volley</code>,找来找去关于<code>Volley</code>的资料几乎没有，在Google中找到了这篇文章，看了觉得不错，于是就决定翻译一下，一来加深自己的理解，二来呢顺便补一下自己那惨不忍睹的英语。由于本人英语水平比较烂，翻译的时候有可能会曲解原作者的意思，建议英语好的大牛飘过此文去看作者的原文，欢迎大家吐槽和拍砖，觉得译文中有那些地方我翻译的不妥的地方欢迎回复指正，我们相互学习～～～</p>

<h4 id="section-5">声明</h4>

<p>转载须以超链接形式标明文章原始出处和作者信息及<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">版权声明</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[转]Android开发规范]]></title>
    <link href="http://inferjay.github.io/blog/2013/07/18/the-android-developer-standard/"/>
    <updated>2013-07-18T22:18:00+08:00</updated>
    <id>http://inferjay.github.io/blog/2013/07/18/the-android-developer-standard</id>
    <content type="html"><![CDATA[<h3 id="android">一、Android编码规范</h3>

<p>1.java代码中不出现中文，最多注释中可以出现中文</p>

<p>2.局部变量命名、静态成员变量命名</p>

<pre><code>只能包含字母，单词首字母出第一个外，都为大写，其他字母都为小写
</code></pre>

<p>3.常量命名</p>

<pre><code>只能包含字母和_，字母全部大写，单词之间用_隔开
</code></pre>

<p>4.layout中的id命名</p>

<pre><code>命名模式为：view缩写_模块名称_view的逻辑名称
</code></pre>

<p>view的缩写详情如下:</p>

<ul>
  <li>LayoutView：lv</li>
  <li>RelativeView:rv</li>
  <li>TextView:tv</li>
  <li>ImageView:iv</li>
  <li>ImageButton:im</li>
  <li>Button:btn</li>
  <li>……</li>
</ul>

<!--more-->

<p>5.activity中的view变量命名</p>

<pre><code>命名模式为：逻辑名称+view缩写
</code></pre>

<h6 id="section">建议:</h6>
<p>如果layout文件很复杂，建议将layout分成多个模块，每个模块定义一个moduleViewHolder，其成员变量包含所属view</p>

<p>6.strings.xml中的id命名</p>

<pre><code>命名模式：activity名称_功能模块名称_逻辑名称/activity名称_逻辑名称/common_逻辑名称
</code></pre>

<p>strings.xml中，使用activity名称注释，将文件内容区分开来</p>

<p>7.drawable中的图片命名</p>

<pre><code>命名模式：activity名称_逻辑名称/common_逻辑名称
</code></pre>

<p>8.styles.xml</p>

<p>将layout中不断重现的style提炼出通用的style通用组件，放到styles.xml中；</p>

<p>9.使用layer-list和selector</p>

<p>10.图片尽量分拆成多个可重用的图片</p>

<p>11.服务端可以实现的，就不要放在客户端</p>

<p>12.引用第三方库要慎重，避免应用大容量的第三方库，导致客户端包非常大</p>

<p>13.处理应用全局异常和错误，将错误以邮件的形式发送给服务端</p>

<p>14.图片的.9处理</p>

<p>15.使用静态变量方式实现界面间共享要慎重</p>

<p>16.Log(系统名称 模块名称 接口名称，详细描述)</p>

<p>17.单元测试（逻辑测试、界面测试）</p>

<p>18.不要重用父类的handler，对应一个类的handler也不应该让其子类用到，否则会导致message.what冲突</p>

<p>19.activity中在一个View.OnClickListener中处理所有的逻辑</p>

<p>19.strings.xml中使用%1$s实现字符串的通配</p>

<p>21.如果多个Activity中包含共同的UI处理，那么可以提炼一个CommonActivity，把通用部分叫由它来处理，其他activity只要继承它即可</p>

<p>22.使用button+activitgroup实现tab效果时，使用Button.setSelected(true)，确保按钮处于选择状态，并使activitygroup的当前activity与该button对应</p>

<p>23.如果所开发的为通用组件，为避免冲突，将drawable/layout/menu/values目录下的文件名增加前缀</p>

<p>24.数据一定要效验</p>

<pre><code>例如:字符型转数字型，如果转换失败一定要有缺省值；服务端响应数据是否有效判断；
</code></pre>

<h3 id="android-1">二、Android性能优化</h3>

<p>1.http用gzip压缩，设置连接超时时间和响应超时时间</p>

<p>http请求按照业务需求，分为是否可以缓存和不可缓存，那么在无网络的环境中，仍然通过缓存的httpresponse浏览部分数据，实现离线阅读。</p>

<p>2.listview 性能优化</p>

<ul>
  <li>
    <p>复用convertView</p>

    <p>在getItemView中，判断convertView是否为空，如果不为空，可复用。如果couvertview中的view需要添加listerner，代码一定要在if(convertView==null){}之外。</p>
  </li>
  <li>
    <p>异步加载图片</p>

    <p>item中如果包含有webimage，那么最好异步加载</p>
  </li>
  <li>
    <p>快速滑动时不显示图片</p>

    <p>当快速滑动列表时（SCROLL_STATE_FLING），item中的图片或获取需要消耗资源的view，可以不显示出来；而处于其他两种状态（SCROLL_STATE_IDLE 和SCROLL_STATE_TOUCH_SCROLL），则将那些view显示出来</p>
  </li>
</ul>

<p>3.使用线程池，分为核心线程池和普通线程池，下载图片等耗时任务放置在普通线程池，避免耗时任务阻塞线程池后，导致所有异步任务都必须等待</p>

<p>4.异步任务，分为核心任务和普通任务，只有核心任务中出现的系统级错误才会报错，异步任务的ui操作需要判断原activity是否处于激活状态</p>

<p>5.尽量避免static成员变量引用资源耗费过多的实例,比如Context</p>

<p>6.使用WeakReference代替强引用，弱引用可以让您保持对对象的引用，同时允许GC在必要时释放对象，回收内存。对于那些创建便宜但耗费大量内存的对象，即希望保持该对象，又要在应用程序需要时使用，同时希望GC必要时回收时，可以考虑使用弱引用。</p>

<p>7.超级大胖子Bitmap</p>

<ul>
  <li>及时的销毁(Activity的onDestroy时，将bitmap回收)</li>
  <li>设置一定的采样率</li>
  <li>巧妙的运用软引用</li>
  <li>drawable对应resid的资源，bitmap对应其他资源8.保证Cursor 占用的内存被及时的释放掉，而不是等待GC来处理。并且 Android明显是倾向于编程者手动的将Cursor close掉</li>
</ul>

<p>9.线程也是造成内存泄露的一个重要的源头。线程产生内存泄露的主要原因在于线程生命周期的不可控</p>

<p>10.如果ImageView的图片是来自网络，进行异步加载</p>

<p>11.应用开发中自定义View的时候，交互部分，千万不要写成线程不断刷新界面显示，而是根据TouchListener事件主动触发界面的更新</p>

<h3 id="androidui">三、AndroidUI优化</h3>

<p>1.layout组件化，尽量使用merge及include复用</p>

<p>2.使用styles，复用样式定义</p>

<p>3.软键盘的弹出控制，不要让其覆盖输入框</p>

<p>4.数字、字母和汉字混排占位问题：将数字和字母全角化。由于现在大多数情况下我们的输入都是半角，所以 字母和数字的占位无法确定，但是一旦全角化之后，数字、字母的占位就和一个汉字的占位相同了，这样就可以避免由于占位导致的排版问题。</p>

<p>5.英文文档排版：textview自动换行时要保持单词的完整性，解决方案是计算字符串长度，然后手动设定每一行显示多少个字母并加上‘n‘</p>

<p>6.复杂布局使用RelativeLayout</p>

<p>7.自适应屏幕，使用dp替代pix</p>

<p>8.使用android:layout_weight或者TableLayout制作等分布局</p>

<p>9.使用animation-list制作动画效果</p>

<h6 id="zhoujiyu0929">原文作者： zhoujiyu0929</h6>

<h6 id="httpmyeoecnyyz168archive5551html">原文地址： http://my.eoe.cn/yyz168/archive/5551.html</h6>
]]></content>
  </entry>
  
</feed>
