<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Inferjay的技术博客]]></title>
  <link href="http://inferjay.github.io/atom.xml" rel="self"/>
  <link href="http://inferjay.github.io/"/>
  <updated>2013-08-04T11:58:18+08:00</updated>
  <id>http://inferjay.github.io/</id>
  <author>
    <name><![CDATA[inferjay]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[译]Google　I/O 2013:Volley 图片缓存教程]]></title>
    <link href="http://inferjay.github.io/blog/2013/08/03/google-i-o-2013-volley-image-cache-tutorial/"/>
    <updated>2013-08-03T11:28:00+08:00</updated>
    <id>http://inferjay.github.io/blog/2013/08/03/google-i-o-2013-volley-image-cache-tutorial</id>
    <content type="html"><![CDATA[<p>Gooogle I/O 2013已经结束了，并且对于Android开发的未来它给我们留下了更大的期望。令人非常兴奋的是在今年的I/O大会上展示了一个叫<a href="https://android.googlesource.com/platform/frameworks/volley/"><code>Volley</code></a>的库。<code>Volley</code>是一个处理和缓存网络请求的库，减少开发人员在实际的每一个应用中写同样的样板代码。写样板代码是很无聊的并且也增加了开发人员出错的几率。Google是出于这些考虑创建了<code>Volley</code>。</p>

<p>如果你还没有看过<a href="https://developers.google.com/events/io/sessions/325304728">Gooogle　I/O中关于Volley的介绍</a>，在继续这篇文章之前我建议你先去看看关于<code>Volley</code>的介绍，对它有一些基本的理解。</p>

<p>在Google I/O介绍的时候，Ficus Kirpatrick讲了很多关于Volley如何的有助于图片加载。你会发现在Volley作为你的图片加载解决方案的时候，虽然Volley自己处理了L2的缓存，它需要但是没有包含L1的缓存。许多人会使用像<a href="https://github.com/nostra13/Android-Universal-Image-Loader">Universal Image Loader</a>或者<a href="https://github.com/square/picasso">Square`s newer Picasso</a>这些第三方的库去处理图片的加载；然而这些库通常已经同时处理了图片的加载和缓存。所以，我们如何使用Volley来替换图片的加载和缓存呢？首先，让我们看看Volley提供的便利的加载方法，我们稍后再看他们的不同之处。</p>

<!--More-->

<h4 id="imageloader">ImageLoader</h4>

<p><code>ImageLoader</code>这个类需要一个<code>Request</code>的实例以及一个<code>ImageCache</code>的实例。图片通过一个<code>URL</code>和一个<code>ImageListener</code>实例的<code>get()</code>方法就可以被加载。从哪里，<code>ImageLoader</code>会检查<code>ImageCache</code>,而且如果缓存里没有图片就会从网络上获取。</p>

<h4 id="networkimageview">NetworkImageView</h4>

<p>这个类在布局文件中替换<code>ImageViews</code>，并且将使用<code>ImageLoader</code>。<code>NetworkImageView</code>的<code>setUrl()</code>这个方法需要一个字符串的URL路径以及一个<code>ImageLoader</code>的实例。然后它使用<code>ImageLoader</code>的<code>get()</code>方法获取图片数据。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">&lt;com.android.volley.toolbox.NetworkImageView
</span><span class="line">    android:id="@+id/twitterUserImage"
</span><span class="line">    android:layout_alignParentLeft="true"
</span><span class="line">    android:layout_alignParentTop="true"
</span><span class="line">    android:layout_width="40dp"
</span><span class="line">    android:layout_height="40dp"
</span><span class="line">    android:padding="5dp"
</span><span class="line">    /&gt;
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="imagecache">ImageCache</h4>

<p><code>Volley</code>的<code>ImageCache</code>接口允许你使用你喜欢的L1缓存实现。不幸的是<code>Volley</code>没有提供默认的实现。在I/O的介绍中展示了<code>BitmapLruCache</code>的一点代码片段，但是<code>Volley</code>这个库本身并不包含任何相关的实现。</p>

<p><code>ImageCache</code>接口有两个方法，<code>getBitmap(String url)</code>和<code>putBitmap(String url, Bitmap bitmap)</code>.这两个方法足够简单直白，他们可以添加任何的缓存实现。</p>

<h4 id="volley">在Volley中添加图片缓存</h4>

<p>对于这个例子，我创建了<a href="https://github.com/rdrobinson3/VolleyImageCacheExample">一个简单的应用</a>，它从Twitter上搜索提取“CapTech”这个词的推文，并且把包含这个词的推文的用户名和照片显示在一个ListView中，在你滑动这个列表的时候将自动加载以前的记录，并根据需要从缓存中拉取图片。</p>

<p><img src="http://inferjay.github.io/images/notes_images/volley-example.png" alt="alt text" title="volley-example" /></p>

<p>例子里有２个可用的缓存实现。一个基于内存的LRU缓存。对于磁盘缓存实现我选择使用由Jake Wharton写的<a href="https://github.com/JakeWharton/DiskLruCache">DiskLruCache</a>。我只所以选择这个实现是因为他在Android社区中被经常使用和推荐的并且有一些人试图去改进它。使用一个基于磁盘的L1缓存有可能导致i/o阻塞的问题。<code>Volley</code>已经内置了一个磁盘L2缓存。磁盘L1缓存包括在内了，由于我原来不知道<code>Volley</code>是如何处理图片请求缓存的。</p>

<h3 id="section">在这个例子中主要的组件实现如下:</h3>

<h4 id="requestmanager">RequestManager</h4>

<p><code>RequestManager</code>维护了我们的一个<code>RequestQueue</code>的引用。<code>Volley</code>使用RequestQueue不仅处理了我们给Twitter的数据请求，而且也处理了我的的图片加载。</p>

<h4 id="requestqueue">RequestQueue</h4>

<p>这个类虽然跟图片加载没有直接的关系，但是它是具有代表性，它是如何继承<code>Volley</code>的<code>Request</code>类去处理你的JSON解析。它使用GET请求到Twtter并获取<code>TwitterData</code>对象。</p>

<h4 id="bitmaplruimagecache">BitmapLruImageCache</h4>

<p>这是一个基于<code>“least recently used(最近最少使用算法,简称LRU)”</code>内存缓存实现。它是快速的并且不会引起I/O阻塞的。推荐这种方法。</p>

<h4 id="disklruimagecache">DiskLruImageCache</h4>

<p><code>DiskLruImageCache</code>是一个<code>DiskLruCache</code>和<code>bitmap-centered</code>的包装实现。它从<code>DiskLruCache</code>中获取和添加<code>bitmaps</code>，并且处理缓存的实例。一个磁盘缓存或许会引起I/O的阻塞。</p>

<h4 id="imagecachemanager">ImageCacheManager</h4>

<p><code>ImageCacheManager</code>持有一个我们的<code>ImageCache</code>和<code>Volley ImageLoader</code>的引用。</p>

<p>有一件事情你要注意，在ImageCacheManager中我们使用了字符串URL的hashCode()值作为缓存的Key。这么做是因为在URL中的某些字符不能作为缓存的Key。</p>

<h4 id="buzzarrayadapter">BuzzArrayAdapter</h4>

<p>这是一个简单的Adapter。这里唯一要注意的是我们实现了Volley的Listener和ErrListener接口并且将这个Adapter作为
NetworkImageView’s的setUrl(String string , Listener listener, ErrorListener errorListener) 方法的Listener。这个Adapter还有一点额外的代码，用来在滚动的时候加载老的推文。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Tweet tweet = mData.get(position);
</span><span class="line">if(tweet != null){
</span><span class="line">viewHolder.twitterUserImage.setImageUrl(tweet.getUserImageUrl(),ImageCacheManager.getInstance().getImageLoader());
</span><span class="line">	viewHolder.userNameTextView.setText("@" + tweet.getUsername());
</span><span class="line">	viewHolder.messageTextView.setText(tweet.getMessage());
</span><span class="line">	viewHolder.tweetTimeTextView.setText(formatDisplayDate(tweet.getCreatedDate()));
</span><span class="line">	viewHolder.destinationUrl = tweet.getDestinationUrl();
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="putting-it-all-together">Putting it all together</h4>

<p>把这些组件组合在一起，图片加载和缓存是如此的简单。在启动时，在<code>MainApplication</code>这个类中初始化<code>RequestManager</code>和<code>ImageCacheManager</code>。在那里你可以定义你想要的L1缓存类型。内存缓存是默认的。</p>

<p>在<code>MainActivity</code>中我们调用<code>TwitterManager</code>并且加载我们的的初始数据集。一旦我们接收到响应我们就把这个响应传递给一个<code>BuzzArrayAdapter</code>并把这个<code>Adapter</code>设置到我们的<code>ListView</code>上。</p>

<p>正如我们已经在上面看到了<code>BuzzArrayAdapter</code>的代码,对于<code>NetworkImageView</code>所有繁重的图片加载操作我们仅仅需要从我们的<code>ImageCacheManager</code>中获取一个ImageLoader的实例传递给它就可以了。</p>

<p><code>ImageCacheManager</code>会检查我的LRU缓存实现并且如果这个图片是可用的就会返回它。如果这个图片不在在缓存中那么就从网络获取它。</p>

<p>当你滚动<code>ListView</code>的时候<code>BuzzArrayAdapter</code>将一起加载额外的推文和图片，并且重用在缓存中已经存在的图片。</p>

<h4 id="closing-thoughts-on-volley">Closing Thoughts on Volley</h4>
<p>虽然<code>Volley</code>是好用的，快速的，很容易实现的；但他也有一些不足的地方:</p>

<ul>
  <li>这个库没有任何的文档和例子。</li>
  <li>比如缓存配置组件，他们为什么不做成可配置的。</li>
  <li>从以上可以看出，除了一个比较奇怪的基本图片缓存实现以外,它甚至可能有使用NoImageCache的实现,或者在缓存完全可选的时候，你只是想从网络上获取任何东西。</li>
</ul>

<p>关于Volley在开发者社区中有很多令人激动的事情，并且有很的好的理由。感觉它就像一个库，它包含了一部分旧的Android API.像在I/O上公布的新的定位API,它是非常纯净的~~~~</p>

<h4 id="github">Github上的例子源码</h4>

<p><a href="https://github.com/rdrobinson3/VolleyImageCacheExample">VolleyImageCacheExample</a></p>

<h4 id="section-1">附件:</h4>

<p><a href="http://blogs.captechconsulting.com/sites/default/files/VolleyImageCacheExample-master.zip">VolleyImageCacheExample-master.zip</a></p>

<h4 id="section-2">原文作者:</h4>

<p>Trey Robinson</p>

<h4 id="section-3">原文地址:</h4>

<p><a href="http://blogs.captechconsulting.com/blog/raymond-robinson/google-io-2013-volley-image-cache-tutorial">http://blogs.captechconsulting.com/blog/raymond-robinson/google-io-2013-volley-image-cache-tutorial</a></p>

<h4 id="section-4">关于本文</h4>

<p>前端时间偶然间看到了<code>Volley</code>，最近开始做一个新项目又重新去看了看I/O中关于<code>Volley</code>的介绍,感觉<code>Volley</code>很牛逼，于是就想在新项目中试试<code>Volley</code>,找来找去关于<code>Volley</code>的资料几乎没有，在Google中找到了这篇文章，看了觉得不错，于是就决定翻译一下，一来加深自己的理解，二来呢顺便补一下自己那惨不忍睹的英语。由于本人英语水平比较烂，翻译的时候有可能会曲解原作者的意思，建议英语好的大牛飘过此文去看作者的原文，欢迎大家吐槽和拍砖，觉得译文中有那些地方我翻译的不妥的地方欢迎回复指正，我们相互学习～～～</p>

<h4 id="section-5">声明</h4>

<p>转载须以超链接形式标明文章原始出处和作者信息及<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">版权声明</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[转]Android开发规范]]></title>
    <link href="http://inferjay.github.io/blog/2013/07/18/the-android-developer-standard/"/>
    <updated>2013-07-18T22:18:00+08:00</updated>
    <id>http://inferjay.github.io/blog/2013/07/18/the-android-developer-standard</id>
    <content type="html"><![CDATA[<h3 id="android">一、Android编码规范</h3>

<p>1.java代码中不出现中文，最多注释中可以出现中文</p>

<p>2.局部变量命名、静态成员变量命名</p>

<pre><code>只能包含字母，单词首字母出第一个外，都为大写，其他字母都为小写
</code></pre>

<p>3.常量命名</p>

<pre><code>只能包含字母和_，字母全部大写，单词之间用_隔开
</code></pre>

<p>4.layout中的id命名</p>

<pre><code>命名模式为：view缩写_模块名称_view的逻辑名称
</code></pre>

<p>view的缩写详情如下:</p>

<ul>
  <li>LayoutView：lv</li>
  <li>RelativeView:rv</li>
  <li>TextView:tv</li>
  <li>ImageView:iv</li>
  <li>ImageButton:im</li>
  <li>Button:btn</li>
  <li>……</li>
</ul>

<!--more-->

<p>5.activity中的view变量命名</p>

<pre><code>命名模式为：逻辑名称+view缩写
</code></pre>

<h6 id="section">建议:</h6>
<p>如果layout文件很复杂，建议将layout分成多个模块，每个模块定义一个moduleViewHolder，其成员变量包含所属view</p>

<p>6.strings.xml中的id命名</p>

<pre><code>命名模式：activity名称_功能模块名称_逻辑名称/activity名称_逻辑名称/common_逻辑名称
</code></pre>

<p>strings.xml中，使用activity名称注释，将文件内容区分开来</p>

<p>7.drawable中的图片命名</p>

<pre><code>命名模式：activity名称_逻辑名称/common_逻辑名称
</code></pre>

<p>8.styles.xml</p>

<p>将layout中不断重现的style提炼出通用的style通用组件，放到styles.xml中；</p>

<p>9.使用layer-list和selector</p>

<p>10.图片尽量分拆成多个可重用的图片</p>

<p>11.服务端可以实现的，就不要放在客户端</p>

<p>12.引用第三方库要慎重，避免应用大容量的第三方库，导致客户端包非常大</p>

<p>13.处理应用全局异常和错误，将错误以邮件的形式发送给服务端</p>

<p>14.图片的.9处理</p>

<p>15.使用静态变量方式实现界面间共享要慎重</p>

<p>16.Log(系统名称 模块名称 接口名称，详细描述)</p>

<p>17.单元测试（逻辑测试、界面测试）</p>

<p>18.不要重用父类的handler，对应一个类的handler也不应该让其子类用到，否则会导致message.what冲突</p>

<p>19.activity中在一个View.OnClickListener中处理所有的逻辑</p>

<p>19.strings.xml中使用%1$s实现字符串的通配</p>

<p>21.如果多个Activity中包含共同的UI处理，那么可以提炼一个CommonActivity，把通用部分叫由它来处理，其他activity只要继承它即可</p>

<p>22.使用button+activitgroup实现tab效果时，使用Button.setSelected(true)，确保按钮处于选择状态，并使activitygroup的当前activity与该button对应</p>

<p>23.如果所开发的为通用组件，为避免冲突，将drawable/layout/menu/values目录下的文件名增加前缀</p>

<p>24.数据一定要效验</p>

<pre><code>例如:字符型转数字型，如果转换失败一定要有缺省值；服务端响应数据是否有效判断；
</code></pre>

<h3 id="android-1">二、Android性能优化</h3>

<p>1.http用gzip压缩，设置连接超时时间和响应超时时间</p>

<p>http请求按照业务需求，分为是否可以缓存和不可缓存，那么在无网络的环境中，仍然通过缓存的httpresponse浏览部分数据，实现离线阅读。</p>

<p>2.listview 性能优化</p>

<ul>
  <li>
    <p>复用convertView</p>

    <p>在getItemView中，判断convertView是否为空，如果不为空，可复用。如果couvertview中的view需要添加listerner，代码一定要在if(convertView==null){}之外。</p>
  </li>
  <li>
    <p>异步加载图片</p>

    <p>item中如果包含有webimage，那么最好异步加载</p>
  </li>
  <li>
    <p>快速滑动时不显示图片</p>

    <p>当快速滑动列表时（SCROLL_STATE_FLING），item中的图片或获取需要消耗资源的view，可以不显示出来；而处于其他两种状态（SCROLL_STATE_IDLE 和SCROLL_STATE_TOUCH_SCROLL），则将那些view显示出来</p>
  </li>
</ul>

<p>3.使用线程池，分为核心线程池和普通线程池，下载图片等耗时任务放置在普通线程池，避免耗时任务阻塞线程池后，导致所有异步任务都必须等待</p>

<p>4.异步任务，分为核心任务和普通任务，只有核心任务中出现的系统级错误才会报错，异步任务的ui操作需要判断原activity是否处于激活状态</p>

<p>5.尽量避免static成员变量引用资源耗费过多的实例,比如Context</p>

<p>6.使用WeakReference代替强引用，弱引用可以让您保持对对象的引用，同时允许GC在必要时释放对象，回收内存。对于那些创建便宜但耗费大量内存的对象，即希望保持该对象，又要在应用程序需要时使用，同时希望GC必要时回收时，可以考虑使用弱引用。</p>

<p>7.超级大胖子Bitmap</p>

<ul>
  <li>及时的销毁(Activity的onDestroy时，将bitmap回收)</li>
  <li>设置一定的采样率</li>
  <li>巧妙的运用软引用</li>
  <li>drawable对应resid的资源，bitmap对应其他资源8.保证Cursor 占用的内存被及时的释放掉，而不是等待GC来处理。并且 Android明显是倾向于编程者手动的将Cursor close掉</li>
</ul>

<p>9.线程也是造成内存泄露的一个重要的源头。线程产生内存泄露的主要原因在于线程生命周期的不可控</p>

<p>10.如果ImageView的图片是来自网络，进行异步加载</p>

<p>11.应用开发中自定义View的时候，交互部分，千万不要写成线程不断刷新界面显示，而是根据TouchListener事件主动触发界面的更新</p>

<h3 id="androidui">三、AndroidUI优化</h3>

<p>1.layout组件化，尽量使用merge及include复用</p>

<p>2.使用styles，复用样式定义</p>

<p>3.软键盘的弹出控制，不要让其覆盖输入框</p>

<p>4.数字、字母和汉字混排占位问题：将数字和字母全角化。由于现在大多数情况下我们的输入都是半角，所以 字母和数字的占位无法确定，但是一旦全角化之后，数字、字母的占位就和一个汉字的占位相同了，这样就可以避免由于占位导致的排版问题。</p>

<p>5.英文文档排版：textview自动换行时要保持单词的完整性，解决方案是计算字符串长度，然后手动设定每一行显示多少个字母并加上‘n‘</p>

<p>6.复杂布局使用RelativeLayout</p>

<p>7.自适应屏幕，使用dp替代pix</p>

<p>8.使用android:layout_weight或者TableLayout制作等分布局</p>

<p>9.使用animation-list制作动画效果</p>

<h6 id="zhoujiyu0929">原文作者： zhoujiyu0929</h6>

<h6 id="httpmyeoecnyyz168archive5551html">原文地址： http://my.eoe.cn/yyz168/archive/5551.html</h6>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[转]Java 的版本历史与特性]]></title>
    <link href="http://inferjay.github.io/blog/2013/07/17/the-java-version-of-the-history-and-characteristics/"/>
    <updated>2013-07-17T15:53:00+08:00</updated>
    <id>http://inferjay.github.io/blog/2013/07/17/the-java-version-of-the-history-and-characteristics</id>
    <content type="html"><![CDATA[<p>一个比较流行的问题是，“Java下一个版本会有什么特性呢？” 。这是否是个好问题却有待商榷。在下面的内容里，我总结了至今为止的Java主要发行版中各自引入的新特性，这样做的目的是为了突出各个新特性是在哪个发行版中引入的。除了列出的特性外，每个发行版还做了很多优化和修复BUG的工作。</p>

<h3 id="java-version-se-7">Java Version SE 7</h3>

<p>开发代号是Dolphin（海豚），于2011-07-28发行。</p>

<p><img src="http://inferjay.github.io/images/notes_images/dolphin.png" alt="alt text" title="Dolphin" /></p>

<p>引入的新特性包括：</p>

<ul>
  <li>switch语句块中允许以字符串作为分支条件；</li>
  <li>在创建泛型对象时应用类型推断；</li>
  <li>在一个语句块中捕获多种异常；</li>
  <li>支持动态语言；</li>
  <li>支持try-with-resources；</li>
  <li>引入Java NIO.2开发包；</li>
  <li>数值类型可以用2进制字符串表示，并且可以在字符串表示中添加下划线；</li>
  <li>钻石型语法；</li>
  <li>null值的自动处理。</li>
</ul>

<!--more-->

<h3 id="java-version-se-6">Java Version SE 6</h3>

<p>开发代号为Mustang（野马），于2006-12-11发行。</p>

<p><img src="http://inferjay.github.io/images/notes_images/Mustang.png" alt="alt text" title="Mustang" /></p>

<p>引入的新特性包括：</p>

<ul>
  <li>支持脚本语言；</li>
  <li>引入JDBC 4.0 API；</li>
  <li>引入Java Compiler API；</li>
  <li>可插拔注解；</li>
  <li>增加对Native PKI(Public Key Infrastructure)、Java GSS(Generic Security Service)、Kerberos和LDAP(Lightweight Directory Access Protocol)的支持；</li>
  <li>继承Web Services；</li>
  <li>做了很多优化。</li>
</ul>

<h3 id="java-version-se-50">Java Version SE 5.0</h3>

<p>开发代号为Tiger（老虎），于2004-09-30发行。</p>

<p><img src="http://inferjay.github.io/images/notes_images/tiger.jpg" alt="alt text" title="Tiger" /></p>

<p>引入的新特性包括:</p>

<ul>
  <li>引入泛型；</li>
  <li>增强循环，可以使用迭代方式；</li>
  <li>自动装箱与自动拆箱；</li>
  <li>类型安全的枚举；</li>
  <li>可变参数；</li>
  <li>静态引入；</li>
  <li>元数据（注解）；</li>
  <li>引入Instrumentation。</li>
</ul>

<h3 id="j2se-version-14">J2SE Version 1.4</h3>

<p>开发代号为Merlin（隼），于2004-02-06发行（首次在JCP下发行）。</p>

<p><img src="http://inferjay.github.io/images/notes_images/merlin.jpg" alt="alt text" title="Merlin" /></p>

<p>引入的新特性包括:</p>

<ul>
  <li>XML处理；</li>
  <li>Java打印服务；</li>
  <li>引入Logging API；</li>
  <li>引入Java Web Start；</li>
  <li>引入JDBC 3.0 API；</li>
  <li>引入断言；</li>
  <li>引入Preferences API；</li>
  <li>引入链式异常处理；</li>
  <li>支持IPv6；</li>
  <li>支持正则表达式；</li>
  <li>引入Image I/O slot machine API。</li>
</ul>

<h3 id="j2se-version-13">J2SE Version 1.3</h3>

<p>开发代号为Kestrel（红隼），于2000-05-08发行。</p>

<p><img src="http://inferjay.github.io/images/notes_images/Kestrel.jpg" alt="alt text" title="Kestrel" /></p>

<p>引入的新特性包括：</p>

<ul>
  <li>引入Java Sound API；</li>
  <li>jar文件索引；</li>
  <li>对Java的各个方面都做了大量优化和增强。</li>
</ul>

<h3 id="j2se-version-12">J2SE Version 1.2</h3>

<p>开发代号为Playground（操场），于1998-12-08发行。</p>

<p>引入的新特性包括：</p>

<ul>
  <li>引入集合（Collection）框架；</li>
  <li>对字符串常量做内存映射；</li>
  <li>引入JIT（Just In Time）编译器；</li>
  <li>引入对打包的Java文件进行数字签名；</li>
  <li>引入控制授权访问系统资源的策略工具；</li>
  <li>引入JFC（Java Foundation Classes），包括Swing 1.0、拖放和Java 2D类库；</li>
  <li>引入Java 插件；</li>
  <li>在JDBC中引入可滚动结果集、BLOB、CLOB、批量更新和用户自定义类型；</li>
  <li>在Applet中添加声音支持。</li>
</ul>

<h3 id="jdk-version-11">JDK Version 1.1</h3>

<p>于1997-02-19发行。</p>

<p>引入的新特性包括：</p>

<ul>
  <li>引入JDBC（Java Database Connectivity）；</li>
  <li>支持内部类；</li>
  <li>引入Java Bean；</li>
  <li>引入RMI（Remote Method Invocation）；</li>
  <li>引入反射（仅用于内省）。</li>
</ul>

<h3 id="jdk-version-10">JDK Version 1.0</h3>

<p>开发代号为Oak（橡树），于1996-01-23发行。</p>

<p>英文原文：javapapers ，编译：ImportNew  - 曹旭东
译文地址： http://www.importnew.com/844.html</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用开源协议收集整理]]></title>
    <link href="http://inferjay.github.io/blog/2013/06/24/open-source-licenses-are-collected/"/>
    <updated>2013-06-24T14:35:00+08:00</updated>
    <id>http://inferjay.github.io/blog/2013/06/24/open-source-licenses-are-collected</id>
    <content type="html"><![CDATA[<h4 id="section">声明:本文大部分内容摘自网络这里仅做搜集整理以备自用！！</h4>

<p>全球都在刮着开源风，开源软件在现如今的软件行业中也越来越重要了，从国外的Google code、Github、Sourceforge以及国内的Gitcafe等开源项目脱管网站就可以看出开源软件的火热程度，开源已经成为软件的发展趋势。而开源软件使用的许可协议也是层出不穷，如果不遵守这些协议规则可能会导致经济上的损失以及法律纠纷。</p>

<h4 id="section-1">目前，现有软件主要分为如下四类：</h4>

<ul>
  <li>专有软件：需要购买，然后才能使用，且只能使用该软件而不能作其他用途。如修改、分享、再发布等。</li>
  <li>共享软件：基本上就是专有软件，但你能在实际购买前试用。</li>
  <li>免费软件：你可以自由的分享和使用该软件，但你无法修改该软件，因为该软件的源代码不是公开的。</li>
  <li>开源软件/自由软件：你能够自由分享该软件与其源代码、使用该软件并可随意修改该软件源码 - 这给予了你最大的自主权。</li>
</ul>

<p>对于商业软件（专有、共享、免费软件）没什么好说的，只能使用而不允许修改及修改后销售，所以其License差别不大，然而对于开源软件，由于涉及到源代码、版权及其再发布问题，衍生出了若干Licenses，通过OSI(Open Source Initiative)组织批准的开源协议已达61种。如果要发布开源软件，最好是选择这些已被批准的开源协议。</p>

<h4 id="section-2">常见的开源协议有：</h4>
<ul>
  <li>Apache License 2.0</li>
  <li>New and Simplified BSD licenses</li>
  <li>GNU General Public License (GPL)</li>
  <li>GNU Library or “Lesser” General Public License (LGPL)</li>
  <li>MIT license</li>
  <li>Mozilla Public License 1.1 (MPL)</li>
  <li>Common Development and Distribution License</li>
  <li>Common Public License 1.0</li>
  <li>Eclipse Public License</li>
  <li>Creative Commons</li>
</ul>

<!--more-->

<h4 id="apache-license-20">Apache License 2.0</h4>

<p>Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布(作为开源或商业软件)。需要满足的条件：</p>

<ul>
  <li>需要给代码的用户一份Apache License</li>
  <li>如果你修改了代码，需要在被修改的文件中说明。</li>
  <li>在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。</li>
  <li>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache License。你可以在Notice中增加自己的许可，但不可以表现为对Apache License构成更改。</li>
</ul>

<p>Apache Licence也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。</p>

<p><em>要点：商业软件可以使用，也可以修改使用Apache协议的代码。</em></p>

<h4 id="new-and-simplified-bsd-licenses">New and Simplified BSD licenses</h4>

<p>BSD开源协议是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：</p>

<ul>
  <li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</li>
  <li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</li>
  <li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</li>
</ul>

<p>BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p>

<p><em>要点：商业软件可以使用，也可以修改使用BSD协议的代码。</em></p>

<h4 id="gnu-general-public-license-gpl">GNU General Public License (GPL)</h4>

<p>GNU通用公共许可证（简称为GPL），是由自由软件基金会发行的用于计算机软件的许可证。最初由Richard Stallman为GNU计划而撰写。目前大多数的GNU程序和超过半数的自由软件使用此许可证。此许可证最新版本为“版本2”，1991年发布。GNU 宽松通用公共许可证（简称LGPL）是由GPL衍生出的许可证。我们很熟悉的Linux就是采用了GPL。</p>

<p>GPL协议和BSD、Apache License等鼓励代码重用的许可很不一样。
GPL 的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。</p>

<p>GPL协议的主要内容是只要在一个软件中使用GPL协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。GPL协议的产品作为一个单独的产品使用没有任何问题，还可以享受免费的优势。</p>

<p>当一个自由软件使用GPL声明时，该软件的使用者有权重新发布、修改该软件，并得到该软件的源代码；但只要使用者在其程序中使用了该自由软件，或者是使用修改后的软件，那么使用者的程序也必须公布其源代码，同时允许别人发布、修改。也就是说，使用GPL声明下的的自由软件开发出来的新软件也一定是自由软件。</p>

<p>由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，所以商业软件就不适合采用使用GPL协议的开源代码。</p>

<p><em>要点：商业软件不能使用GPL协议的代码。</em></p>

<h4 id="gnu-library-or-lesser-general-public-license-lgpl">GNU Library or “Lesser” General Public License (LGPL)</h4>

<p>LGPL是GPL的变种，也是GNU为了得到更多的甚至是商用软件开发商的支持而提出的。与GPL的最大不同是，可以私有使用LGPL授权的自由软件，开发出来的新软件可以是私有的而不需要是自由软件。所以任何公司在使用自由软件之前应该保证在LGPL或其它GPL变种的授权下。</p>

<p>LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用GPL类库的的软件必须采用GPL协议不同。 LGPL允许商业软件通过类库引用(link)的方式使用LGPL类库而不需要开源商业软件的代码。</p>

<p>但是如果要修改LGPL协议的代码，则涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL不适合以LGPL协议代码为基础进行二次开发的商业软件。</p>

<p><em>要点：商业软件可以使用，但不能修改LGPL协议的代码。</em></p>

<h4 id="mit-license">MIT license</h4>

<p>MIT是和BSD一样宽松的许可协议,作者只想保留版权,而无任何其他的限制.也就是说,你必须在你的发行版里包含原许可协议的声明,无论你是以二进制发布的还是以源代码发布的.MIT 协议可能是几大开源协议中最宽松的一个，核心条款是：
该软件及其相关文档对所有人免费，可以任意处置，包括使用，复制，修改，合并，发表，分发，再授权，或者销售。唯一的限制是，软件中必须包含上述版 权和许可提示。</p>

<p>这意味着：</p>

<ul>
  <li>你可以自由使用，复制，修改，可以用于自己的项目。</li>
  <li>可以免费分发或用来盈利。</li>
  <li>唯一的限制是必须包含许可声明。</li>
  <li>MIT 协议是所有开源许可中最宽松的一个，除了必须包含许可声明外，再无任何限制。</li>
</ul>

<p><em>要点：商业软件可以使用，也可以修改MIT协议的代码，甚至可以出售MIT协议的代码。</em></p>

<h4 id="mozilla-public-license-11-mpl">Mozilla Public License 1.1 (MPL)</h4>

<p>MPL协议允许免费重发布、免费修改，但要求修改后的代码版权归软件的发起者。这种授权维护了商业软件的利益，，它要求基于这种软件得修改无偿贡献版权给该软件。这样，围绕该软件得所有代码得版权都集中在发起开发人得手中。但MPL是允许修改，无偿使用得。MPL软件对链接没有要求。</p>

<p><em>要点：商业软件可以使用，也可以修改MPL协议的代码，但修改后的代码版权归软件的发起者。</em></p>

<h4 id="common-development-and-distribution-license">Common Development and Distribution License</h4>

<p>CDDL（Common Development and Distribution License，通用开发与销售许可）开源协议，是MPL（Mozilla Public License）的扩展协议，它允许公共版权使用，无专利费，并提供专利保护，可集成于商业软件中，允许自行发布许可。
<em>要点：商业软件可以使用，也可以修改CDDL协议的代码。</em></p>

<h4 id="common-public-license-10">Common Public License 1.0</h4>

<p>Common许可证有一些细节性的规定值得参考:</p>

<ul>
  <li>明确了专利授权。一般的开源软件都明确源代码的版权人将自己的修改权、复制权等版权权利向公众许可，但保留署名权，而Common许可证在此基础上还明确假如源代码中含有专利权，源代码专利权人将复制、使用的专有权利向公众许可。</li>
  <li>规定可以将源代码及修改过的源代码与其他类型的不受本许可证约束的代码结合，以新产品的形式发布，只要其中经该许可证获得的源代码及修改过的源代码能按该许可证的要求发布即可。 </li>
  <li>细化了该许可证终止的情形，包括发生专利侵权诉讼。 </li>
  <li>明确了一个独立承担责任的原则，就是假如按该许可证使用源代码的使用者将获得的源代码应用于商业使用，那么他就要对在商业应用中出现的由于使用该源代码程序而产生的侵权诉讼承担完全责任。这一条规定是比较特殊的，绝大多数开源软件许可证都不这么要求。</li>
</ul>

<p><em>要点：商业软件可以使用，也可以修改Common协议的代码，但要承担代码产生的侵权责任。</em></p>

<h4 id="eclipse-public-license">Eclipse Public License</h4>

<p>EPL是一个与CPL相类似的许可证，任何扩展自Eclipse源码的代码也必须是开源的。</p>

<h4 id="creative-commons">Creative Commons</h4>

<p>Creative Commons (CC) 并非严格意义上的开源许可，它主要用于设计。Creative Commons 有多种协议，每种都提供了相应授权模式，CC 协议主要包含 4 种基本形式：</p>

<ul>
  <li>
    <p>署名权</p>

    <p>必须为原始作者署名，然后才可以修改，分发，复制。</p>
  </li>
  <li>
    <p>保持一致</p>

    <p>作品同样可以在 CC 协议基础上修改，分发，复制。</p>
  </li>
  <li>
    <p>非商业</p>

    <p>作品可以被修改，分发，复制，但不能用于商业用途。但商业的定义有些模糊，比如，有的人认为非商业用途指的是不能销售，有的认为是甚至不能放在有广告的网 站，也有人认为非商业的意思是非盈利。</p>
  </li>
  <li>
    <p>不能衍生新作品</p>

    <p>你可以复制，分发，但不能修改，也不能以此为基础创作自己的作品。</p>
  </li>
</ul>

<p>这些许可形式可以结合起来用，其中最严厉的组合是“署名，非商用，不能衍生新作品”，意味着，你可以分享作品，但不能改动或以此盈利，而且必须为原 作者署名。在这种许可模式下，原始作者对作品还拥有完全的控制权，而最宽松的组合是“署名”，意味着，只要为原始作者署名了，就可以自由处置。</p>

<h4 id="section-3">总结：</h4>

<p>目前开源软件比较常使用前5中协议，cc在互联网是也是比较流行的虽然它并非严格意义上的开源协议，并且多见于一些个人博客网站的文章授权声明。
按照使用条件的不同，开源软件许可证可以分为三类（严苛程度递减）</p>

<ul>
  <li>
    <p>使用该开源软件的代码再散布（redistribute）时，源码也必须以相同许可证公开。</p>

    <p>代表许可类型：GPL， AGPL　　</p>
  </li>
  <li>
    <p>使用该开源软件的代码并且对开源代码有所修改后再散布时，源码必须以相同许可证公开。</p>

    <p>代表许可类型：LGPL， CPL，CDDL， CPL，MPL等　　</p>
  </li>
  <li>
    <p>使用该开源软件的代码（包括修改）再散布（redistribute）时，没有特殊限制，只需要明记许可。</p>

    <p>代表许可类型：ASL， BSD，MIT等</p>
  </li>
</ul>

<h5 id="section-4">参考资料</h5>
<p><a href="http://www.cnblogs.com/magic_evan/archive/2011/02/12/1952528.html">http://www.cnblogs.com/magic_evan/archive/2011/02/12/1952528.html</a>
<a href="http://blog.csdn.net/zhulinu/article/details/7419068">http://blog.csdn.net/zhulinu/article/details/7419068</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对Octopress做一些个性化配置]]></title>
    <link href="http://inferjay.github.io/blog/2013/05/10/octopress-config/"/>
    <updated>2013-05-10T20:11:00+08:00</updated>
    <id>http://inferjay.github.io/blog/2013/05/10/octopress-config</id>
    <content type="html"><![CDATA[<h3 id="section">首页只显示部分正文</h3>

<p>在文章任意位置加入</p>

<pre><code>&lt;!--more--&gt;
</code></pre>

<p>这样首页只显示一部分正文，并在每篇文章底下加一个<code>Read on</code>超链接。</p>

<p>然后在<code>_config.yml</code>文件中修改<code>excerpt_link</code>的值<code>Rade on</code>为以你想要的，比如<code>More</code></p>

<h3 id="blog">设置使用指定的编辑器自动打开新建的blog</h3>
<p>每次用<code>rake　new_post</code>新建一篇blog后都要跑到<code>/source/_posts</code>找到新建的blog才能开始写blog，有木有赶脚很不爽，要是每次建完后自动用支持Markdown语法的编辑器打开那该多爽啊，google了一下还这有方法，试了式太爽了，Mark一下以免以后忘记了～～～</p>

<p>打开<code>Rakefile</code>文件，找到<code>## -- Misc Configs -- ##</code>这段注释，然后在<code>server_port</code>下面加入<code>editor = "open"</code></p>

<!--more-->

<h6 id="section-1">如图所示：</h6>

<p><img src="http://inferjay.github.io/images/notes_images/set_open_editer.png" alt="alt text" title="set_open_editer" /> </p>

<p>然后再找到<code>new_post</code>命令，在末尾加入如下代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">  if #{editor}
</span><span class="line">    system "#{editor} #{filename}"
</span><span class="line">  end
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h6 id="section-2">如图所示：</h6>

<p><img src="http://inferjay.github.io/images/notes_images/set_open_editer_code.png" alt="alt text" title="set_open_editer_code" /> </p>

<p>这样每次用<code>rake　new_post</code>新建一篇blog的时候就会自动用指定的编辑器打开直接写blog了～～～</p>

<h3 id="blog-1">设置自动打开浏览器预览生成的blog</h3>

<p>打开<code>Rakefile</code>文件，找到<code>task :preview do</code>这段代码，在其中加入</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">system "sleep 2; open http://localhost:#{server_port}/"
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h6 id="section-3">如图所示：</h6>

<p><img src="http://inferjay.github.io/images/notes_images/set_auto_preview.png" alt="alt text" title="set_auto_preview" /> </p>

<h4 id="section-4">未完待续～～～</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在Mac OS X下升级Ruby到1.9.3版本]]></title>
    <link href="http://inferjay.github.io/blog/2013/05/09/how-to-install-ruby-1-dot-9-3-in-mac-osx/"/>
    <updated>2013-05-09T21:34:00+08:00</updated>
    <id>http://inferjay.github.io/blog/2013/05/09/how-to-install-ruby-1-dot-9-3-in-mac-osx</id>
    <content type="html"><![CDATA[<h3 id="section">安装环境</h3>

<pre><code>* Mac OSX 10.8.3
* Xcode 4.6.1
* Ruby 1.8.7
</code></pre>

<h3 id="rvm">第一步:安装rvm</h3>

<p>为什么要安装rvm呢，因为rvm可以让你拥有多个版本的ruby，并且可以在多个版本之间自由切换。安装方式有两种：单用户模式和多用户模式.而单用户和多用户的区别在于是否有root权限，单用户模式rvm会安装在~/.rvm目录下,而多用户模式则会安装在/usr/local/rvm目录下。</p>

<h6 id="section-1">单用户安装命令：</h6>

<pre><code>bash &lt; &lt;(curl -s https://raw.github.com/wayneeseguin/rvm/master/binscripts/rvm-installer )
</code></pre>

<h6 id="section-2">多用户安装命令：</h6>

<pre><code>sudo bash &lt; &lt;(curl -s https://raw.github.com/wayneeseguin/rvm/master/binscripts/rvm-installer )
</code></pre>

<p>单用户需要设置环境变量，多用户安装重启就行了，确认rvm安装是否成功
在终端输入：</p>

<pre><code>rvm -v
</code></pre>

<p>接着会看到rvm的版本信息如下：</p>

<pre><code>rvm 1.19.6 () by Wayne E. Seguin &lt;wayneeseguin@gmail.com&gt;, Michal Papis &lt;mpapis@gmail.com&gt; 	[https://rvm.io/]
</code></pre>

<!--more-->

<h3 id="ruby">第二步:安装ruby</h3>

<h6 id="gcc">查看是否安装gcc编译器</h6>

<p>在开始安装ruby前请确认你是否安装了gcc，如果你安装了Xcode，请检查是否安装了command line tools, 打开Xcode，在Xcode -&gt; Preference -&gt; Download下，查看“Command Line tools”这一项是否为“installed”
如下图：
<img src="http://inferjay.github.io/images/notes_images/xcode_download_info.png" alt="alt text" title="xcode_download_info" /></p>

<p>如果不是installed，点击install安装或者下载<a href="https://github.com/kennethreitz/osx-gcc-installer" title="OSX-GCC-Installer">OSX-GCC-Installer</a>来安装gcc，不然在安装ruby编译的时候会报误（每个人的环境不一样报的错误也会不一样），如下图：</p>

<p><img src="http://inferjay.github.io/images/notes_images/install_ruby_error_info.png" alt="alt text" title="install_ruby_error_info" /></p>

<h6 id="ruby-1">查看所有可以安装的Ruby版本</h6>

<pre><code>rvm list known
</code></pre>

<p>接着会看到各种版本的Ruby</p>

<h6 id="ruby-2">安装Ruby</h6>

<pre><code>rvm install ruby --head
</code></pre>

<h6 id="ruby193">设置Ruby默认版本为1.9.3版本</h6>

<pre><code>rvm use 1.9.3 --default
</code></pre>

<h3 id="section-3">第三步:更换源</h3>

<h6 id="section-4">查看已有的安装源</h6>

<pre><code>gem source
</code></pre>

<p>显示如下：</p>

<p>CURRENT SOURCES</p>

<p>http://rubygems.org/</p>

<h6 id="section-5">修改更新源</h6>

<pre><code>gem update --system
gem uninstall rubygems-update
gem sources -r http://rubygems.org/
gem sources -a http://ruby.taobao.org
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello Octopress]]></title>
    <link href="http://inferjay.github.io/blog/2013/04/24/hello-octopress/"/>
    <updated>2013-04-24T17:20:00+08:00</updated>
    <id>http://inferjay.github.io/blog/2013/04/24/hello-octopress</id>
    <content type="html"><![CDATA[<h2 id="hello-octopress">Hello Octopress!</h2>

<h3 id="octopress-">Octopress 简介</h3>

<ul>
  <li>基于Jekyll的内容管理工具，可以方便的搭建站点和发布静态页面。</li>
  <li>使用 Markdown 标记语言书写源文件， 通过 Markdown 解析器转换为 HTML 文件。</li>
  <li>写作的时候无需关心文章排版，享受写作的乐趣。</li>
  <li><em>Octopress</em> 与 <em>Github</em> 完美结合，无需学习过多的git命令语法。</li>
  <li><em>Octopress</em> 以 <em>rake</em> 任务的形式实现静态站点页面的生成以及将静态站点发布到_Github pages_，操作十分简单。</li>
  <li>像写程序一样写博客，Github会为你保存你提交的每一个改动。</li>
</ul>

<h2 id="section"></h2>

<h1 id="octopress">Octopress，我来了~~~</h1>
]]></content>
  </entry>
  
</feed>
